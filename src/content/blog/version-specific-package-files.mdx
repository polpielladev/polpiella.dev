---
title: 'Version-specific Package.swift files'
excerpt: ''
pubDate: 2023-06-14
---

I have recently learnt about a feature of Swift Package Manager that allows you to have define `Package.swift` files for specific versions of Swift.

This has recently come in handy for me to test out a new Swift Package Manager feature that is only available to Swift 5.9: [making network requests from Swift Package Plugins](https://www.polpiella.dev/network-requests-in-swift-package-plugins).

In this article I will go through how you can define a version-specific `Package.swift` files and a couple of examples where this feature would be useful.

## Defining a version-specific `Package.swift`

Swift Package Manager allows you to define manifests that only apply to specific versions of Swift.

If you want to change a `Package.swift` file to apply to a specific version only, you can do so by renaming it to `Package@swift-<MAJOR>.<MINOR>.<PATCH>` with the minor and patch not being required.

For example, you could write:

1. `Package@swift-5.7.0`: This manifest would apply exclusively to Swift 5.7.0.
2. `Package@swift-5.7`: This manifest would apply to all patch versions of Swift 5.7.
3. `Package@swift-5`: This manifest would apply to all minor and patch versions of Swift 5.

### `swift-tools` and manifest names

It is also important to note that the `swift-tools` version you define in your Package.swift must be either the same or compatible with the version you define in your file name.

### No matched manifests

If the Swift build system can't find any specific manifests from their file names, it will pick the one that's closest to the Swift toolchain.

For example, if you have three manifests: `Package@swift-5.7.0.swift`, `Package@swift-5.7.1.swift` and `Package@swift-5.7.2.swift`, and you are using Swift 5.9 then SPM will pick the manifest with the closest version definition: `5.7.2`.

## Use cases

The minimum Swift version for a specific package manifest is defined as a **comment** at the top of the `Package.swift` file with the word `swift-tools` followed by the version.

For example, if you wanted to make sure the package is built with Swift 5.9 or newer you would add the following comment at the top of the `Package.swift` file:

```swift:5.9
// swift-tools-version:5.9

import PackageDescription
```

You need to be careful with what you set this version to as, similarly to happens with bumping the minimum deployment version for an app, this prevents any clients of the package from building with a Swift toolchain older than the one defined in the manifest.

Most times, you will be able to keep your `swift-tools` version low or bump them to the latest stable release without having any issues, but in the following sections I will show you a couple of use cases where having version-specific manifests can come in handy

### Example 1: Early adoption

Let's say you want to adopt a new Swift Package Manager feature that has a considerable impact to the Package Manifest API (i.e.: the API you use to write `Package.swift` files) from a Swift version that's still in beta or has recently been released.

To not drop support for your existing clients that haven't updated to the latest Swift toolchain yet, you can maintain both your usual manifest and a _temporary_ version-specific manifest for the latest Swift toolchain.

I had to do this recently to try out the new [`allowNetworkConnections` permission for Swift Package Plugins, which is only available in the manifest API from Swift 5.9](https://www.polpiella.dev/network-requests-in-swift-package-plugins).

I took the `AWSLambdaPackager` plugin from the swift-aws-runtime repository as an example as it needs to make network requests to the Docker daemon and will benefit from this new feature in the future.

This is what a _simplified_ version of the plugin definition looks like:

```swift:Package.swift
// swift-tools-version:5.7

import PackageDescription

let package = Package(
    name: "swift-aws-lambda-runtime",
    platforms: [
        .macOS(.v12),
        .iOS(.v15),
        .tvOS(.v15),
        .watchOS(.v8),
    ],
    products: [
				// ...
        // plugin to package the lambda, creating an archive that can be uploaded to AWS
        .plugin(name: "AWSLambdaPackager", targets: ["AWSLambdaPackager"]),
    ],
    dependencies: [
			// ...
    ],
    targets: [
        .plugin(
            name: "AWSLambdaPackager",
            capability: .command(
                intent: .custom(
                    verb: "archive",
                    description: "Archive the Lambda binary and prepare it for uploading to AWS. Requires docker on macOS or non Amazonlinux 2 distributions."
                )
            )
        )
    ]
)
```

To implement this change with no disruption despite the manifest API changes only being available from Swift 5.9, I created a new manifest for Swift 5.9 only:

```swift:Package@swift-5.9.swift
// üí° Required tools version
// swift-tools-version:5.9

import PackageDescription

let package = Package(
    name: "swift-aws-lambda-runtime",
    platforms: [
        .macOS(.v12),
        .iOS(.v15),
        .tvOS(.v15),
        .watchOS(.v8),
    ],
    products: [
				// ...
        // plugin to package the lambda, creating an archive that can be uploaded to AWS
        .plugin(name: "AWSLambdaPackager", targets: ["AWSLambdaPackager"]),
    ],
    dependencies: [
			// ...
    ],
    targets: [
        .plugin(
            name: "AWSLambdaPackager",
            capability: .command(
                intent: .custom(
                    verb: "archive",
                    description: "Archive the Lambda binary and prepare it for uploading to AWS. Requires docker on macOS or non Amazonlinux 2 distributions."
                )
            ),
            // ‚ú® New permission
            permissions: [
                .allowNetworkConnections(
                    scope: .docker,
                    reason: "AWS Lambda Packager must connect to docker to build on an amazonlinux image"
                )
            ]
        )
    ]
)
```

### Example 2: Compatibility

I have recently worked on a full-stack Swift Package mono repo that collected metrics from different CI/CD providers for a specific app and displayed them on a dashboard.

I came across an issue where I was getting a build error when building my frontend target (built with Vapor) using a Swift 5.7 toolchain.

I decided to switch to 5.6 but I soon realised that one of the dependencies for one of my other targets required me to use Swift 5.7.

This is what _a simplified_ version of the `Package.swift` file looked like:

```swift:Package.swift
// swift-tools-version:5.7
import PackageDescription

let package = Package(
    name: "Metrics",
    platforms: [
       .macOS(.v12)
    ],
    products: [
        .executable(name: "XcodeCloudWebhook", targets: ["XcodeCloudWebhook"])
    ],
    dependencies: [
        // üíß Vapor
        .package(url: "https://github.com/vapor/vapor.git", exact: "4.74.2"),
        .package(url: "https://github.com/vapor/fluent.git", exact: "4.7.1"),
        .package(url: "https://github.com/vapor/fluent-postgres-driver.git", exact: "2.5.1"),
        // ‚ö°Ô∏è AWS Lambda
        .package(url: "https://github.com/swift-server/swift-aws-lambda-runtime.git", exact: "1.0.0-alpha.1"),
        .package(url: "https://github.com/swift-server/swift-aws-lambda-events.git", exact: "0.1.0"),
        // üçÅ Leaf
        .package(url: "https://github.com/vapor/leaf.git", exact: "4.2.4"),
    ],
    targets: [
        // üíß Vapor
        .target(
            name: "App",
            dependencies: [
                .product(name: "Fluent", package: "fluent"),
                .product(name: "FluentPostgresDriver", package: "fluent-postgres-driver"),
                .product(name: "Vapor", package: "vapor"),
                .product(name: "Leaf", package: "leaf")
            ],
            swiftSettings: [
                .unsafeFlags(["-cross-module-optimization"], .when(configuration: .release))
            ]
        ),
        .executableTarget(name: "Run", dependencies: [.target(name: "App")]),
        // ‚ö°Ô∏è AWS Lambda
        .executableTarget(
            name: "XcodeCloudWebhook",
            dependencies: [
                .product(name: "AWSLambdaRuntime", package: "swift-aws-lambda-runtime"),
                .product(name: "AWSLambdaEvents", package: "swift-aws-lambda-events"),
            ]
        ),
    ]
)
```

I could have split the mono repo up into separate packages but since I wanted to keep all products in a single Swift Package, I opted for a different strategy.

I declared a separate _temporary_ manifest for Swift 5.6 (Package-swift-5.6.swift) which allowed me to remove any incompatible dependencies to build and deploy my Vapor frontend:

```swift:Package-swift-5.6.swift
// üí° Just used for building the Vapor frontend
// swift-tools-version:5.6
import PackageDescription

let package = Package(
    name: "Metrics",
    platforms: [
       .macOS(.v12)
    ],
    products: [
    ],
    dependencies: [
        // üíß Vapor
        .package(url: "https://github.com/vapor/vapor.git", exact: "4.74.2"),
        .package(url: "https://github.com/vapor/fluent.git", exact: "4.7.1"),
        .package(url: "https://github.com/vapor/fluent-postgres-driver.git", exact: "2.5.1"),
        // üçÅ Leaf
        .package(url: "https://github.com/vapor/leaf.git", exact: "4.2.4"),
    ],
    targets: [
        // üíß Vapor
        .target(
            name: "App",
            dependencies: [
                .product(name: "Fluent", package: "fluent"),
                .product(name: "FluentPostgresDriver", package: "fluent-postgres-driver"),
                .product(name: "Vapor", package: "vapor"),
                .product(name: "Leaf", package: "leaf")
            ],
            swiftSettings: [
                .unsafeFlags(["-cross-module-optimization"], .when(configuration: .release))
            ]
        ),
        .executableTarget(name: "Run", dependencies: [.target(name: "App")])
    ]
)
```

This approach allowed me to build the Vapor frontend using Swift 5.6 and the AWS lambda using Swift 5.7 as a temporary solution while I investigated why my Vapor application wasn't building for Swift 5.7.

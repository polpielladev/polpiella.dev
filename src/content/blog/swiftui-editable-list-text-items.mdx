---
title: 'Editable text items in a macOS SwiftUI list'
excerpt: 'How to build a macOS SwiftUI list with editable text items.'
pubDate: 2023-03-22
---

import Video from '@components/Video.svelte'

Lists with editable text inputs are a common UI pattern in macOS apps. Apple uses this UI pattern in apps such as the macOS finder or SF Symbols and is so widely used across the ecosystem that it has become a standard known by macOS users.

Despite it being so common, there is no out-of-the-box solution in the standard SwiftUI library to create components like this. I have been building a macOS app which allows users to create and save QR codes and implements this pattern to allow users to rename their saved items.

<Video src="https://res.cloudinary.com/dflewmkx4/video/upload/ac_none,f_auto,q_auto:eco/blog/posts/swiftui-macos-editable-text-views/demo.mp4" />

> I want to give credit to [this Stack Overflow answer](https://stackoverflow.com/a/67864507/17421764) for giving me the idea and inspiration for making my version of a macOS editable text view.

## The editable text component

The `EditableText` component wraps the native `TextField` component to provide extra capabilities while keeping the call site as similar as possible to the standard `TextField`.

### TL;DR

If you want to skip the explanation and just see the code, you can find the full source code for the `EditableText` view here:

```swift:EditableText.swift
struct EditableText: View {
    @Binding var text: String

    @State private var temporaryText: String
    @FocusState private var isFocused: Bool

    init(text: Binding<String>) {
        self._text = text
        self.temporaryText = text.wrappedValue
    }

    var body: some View {
        TextField("", text: $temporaryText, onCommit: { text = temporaryText })
            .focused($isFocused, equals: true)
            .onTapGesture { isFocused = true }
            .onExitCommand { temporaryText = text; isFocused = false }
            .contextMenu {
                Button(action: { isFocused = true }, label: { Text("Rename") })
            }
    }
}
```

### Keeping an internal state

The component takes in a text binding and creates a `temporaryText` internal state variable initialised with the binding's current value. This internal state is necessary to keep hold of the user's edits to the initial text and not update the binding's value until the text's `onCommit` closure gets called.

The `temporaryText` property also allows the component to revert the text to its initial value if the user cancels the edit by pressing the escape key.

```swift:EditableText.swift
struct EditableText: View {
    @Binding var text: String

    @State private var temporaryText: String

    init(text: Binding<String>) {
        self._text = text
        self.temporaryText = text.wrappedValue
    }

    var body: some View {
        TextField("", text: $temporaryText, onCommit: { text = temporaryText })
            .onExitCommand { temporaryText = text }
    }
}
```

### Making the text editable

At the moment, the `EditableText` from the previous section is always editable and focused. You want to change this to just happen whenever the user taps on the text field and, by default the component should be in a non-editable state.

You can achieve this by creating a `@FocusState` property that defaults to `false` and then using passing it as a binding to the `TextField`'s `focused` view modifier. Then, you can use the `onTapGesture` view modifier to set `isFocused` property to true.

```swift:EditableText.swift
struct EditableText: View {
    @Binding var text: String

    @State private var temporaryText: String
    @FocusState private var isFocused: Bool = false

    init(text: Binding<String>) {
        self._text = text
        self.temporaryText = text.wrappedValue
    }

    var body: some View {
        TextField("", text: $temporaryText, onCommit: { text = temporaryText })
            .focused($isFocused, equals: true)
            .onTapGesture { isFocused = true }
    }
}
```

## Roll changes back when the user presses the escape key

The great thing about keeping an internal state and not automatically updating the text binding on every change is that you can roll back the changes when the user presses the escape key and cancels the editing action.

To achieve this, add an `onExitCommand` view modifier to the `TextField`, change the `temporaryText` to the text binding's current value to update the internal state and remove the focus from the `TextField`.

```swift:EditableText.swift
struct EditableText: View {
    @Binding var text: String

    @State private var temporaryText: String
    @FocusState private var isFocused: Bool = false

    init(text: Binding<String>) {
        self._text = text
        self.temporaryText = text.wrappedValue
    }

    var body: some View {
        TextField("", text: $temporaryText, onCommit: { text = temporaryText })
            .focused($isFocused, equals: true)
            .onTapGesture { isFocused = true }
            .onExitCommand { temporaryText = text; isFocused = false }
    }
}
```

## Improving the editable capability's discoverability

If you rely on this UI pattern as the sole meaning of editing a text item, you can improve this feature's discoverability by adding a context menu action to the view. This menu has a single action called 'Rename' which, when tapped, focuses the `TextField` and makes it editable.

```swift:EditableText.swift
struct EditableText: View {
    @Binding var text: String

    @State private var temporaryText: String
    @FocusState private var isFocused: Bool

    init(text: Binding<String>) {
        self._text = text
        self.temporaryText = text.wrappedValue
    }

    var body: some View {
        TextField("", text: $temporaryText, onCommit: { text = temporaryText })
            .focused($isFocused, equals: true)
            .onTapGesture { isFocused = true }
            .onExitCommand { temporaryText = text; isFocused = false }
            .contextMenu {
                Button(action: { isFocused = true }, label: { Text("Rename") })
            }
    }
}
```

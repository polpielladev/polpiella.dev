---
title: 'Editable text items in a macOS SwiftUI list'
excerpt: 'How to build a macOS SwiftUI list with editable text items.'
pubDate: 2023-03-22
---

import Video from '@components/Video.svelte'

Lists with editable text inputs are a common UI pattern in macOS apps. Apple uses this UI pattern in apps such as the macOS finder or SF Symbols and it is used so widely across the ecosystem that it has become a standard known by macOS users.

Despite it being so common, there is no out-of-the-box solution in the standard SwiftUI library to create components like this. I have recently built a macOS app which allows users to create and save QR codes and implements this pattern to allow users to rename their saved items.

<Video src="https://res.cloudinary.com/dflewmkx4/video/upload/ac_none,f_auto,q_auto:eco/blog/posts/swiftui-macos-editable-text-views/demo.mp4" />

> I want to credit to [this Stack Overflow answer](https://stackoverflow.com/a/67864507/17421764) for giving me the idea and inspiration for making my own version of a macOS editable text view.

## The editable text component

The `EditableText` components is a built on top the native `TextField` component and, to prevent layout shifts and frame changes, does not show and hide any extra views.

### TL;DR

If you want to skip the explanation and just see the code, you can find the full source code for the `EditableText` view here:

```swift:EditableText.swift
struct EditableText: View {
    @Binding var text: String

    @State private var temporaryText: String
    @FocusState private var isFocused: Bool

    init(text: Binding<String>) {
        self._text = text
        self.temporaryText = text.wrappedValue
    }

    var body: some View {
        TextField("", text: $temporaryText, onCommit: { text = temporaryText })
            .focused($isFocused, equals: true)
            .onTapGesture { isFocused = true }
            .onExitCommand { temporaryText = text; isFocused = false }
            .contextMenu {
                Button(action: { isFocused = true }, label: { Text("Rename") })
            }
    }
}
```

### Keeping an internal state

The component takes in a text binding and immediately creates a `temporaryText` internal state variable initialisewd with the binding's current value. This internal state is necessary to keep hold of the user's edits to the initial text and not update the binding's value until the text's `onCommit` closure is fired.

The `temporaryText` property also allows the component to revert the text to its initial value if the user cancels the edit by pressing the escape key.

```swift:EditableText.swift
struct EditableText: View {
    @Binding var text: String

    @State private var temporaryText: String

    init(text: Binding<String>) {
        self._text = text
        self.temporaryText = text.wrappedValue
    }

    var body: some View {
        TextField("", text: $temporaryText, onCommit: { text = temporaryText })
            .onExitCommand { temporaryText = text }
    }
}
```

With this set up, the call site for the `EditableText` looks very similar to a standard `TextField`.

### Making the text editable

At the moment, the `EditableText` from the previous section is always editable and focused. You want to change this to only happen whenever the user taps on the text field and, by default the component should be in a non-editable state.

You can achieve this by creating a `@FocusState` property that defaults to `false` and then using passing it as a binding to the `TextField`'s `focused` view modifier. Then, you can use the `onTapGesture` view modifier to set `isFocused` property to true.

```swift:EditableText.swift
struct EditableText: View {
    @Binding var text: String

    @State private var temporaryText: String
    @FocusState private var isFocused: Bool = false

    init(text: Binding<String>) {
        self._text = text
        self.temporaryText = text.wrappedValue
    }

    var body: some View {
        TextField("", text: $temporaryText, onCommit: { text = temporaryText })
            .focused($isFocused, equals: true)
            .onTapGesture { isFocused = true }
    }
}
```

## Roll back changes when user presses the escape key

The great thing about keeping an internal state and not automatically updating the text binding on every change is that you can easily roll back the changes when the user presses the escape key and cancels the editing action.

To achieve this, add an `onExitCommand` view modifier to the `TextField`, change the `temporaryText` to the text binding's current value to update the internal state and remove the focus from the `TextField`.

```swift:EditableText.swift
struct EditableText: View {
    @Binding var text: String

    @State private var temporaryText: String
    @FocusState private var isFocused: Bool = false

    init(text: Binding<String>) {
        self._text = text
        self.temporaryText = text.wrappedValue
    }

    var body: some View {
        TextField("", text: $temporaryText, onCommit: { text = temporaryText })
            .focused($isFocused, equals: true)
            .onTapGesture { isFocused = true }
            .onExitCommand { temporaryText = text; isFocused = false }
    }
}
```

## Improving the editable functionality's discoverability

If you rely on this UI pattern as the sole meaning of editing a text item, you can improve this feature's discoverability by adding a context menu action to the view. This menu has a single action called 'Rename' which, when tapped, focuses the `TextField` and makes it editable.

```swift:EditableText.swift
struct EditableText: View {
    @Binding var text: String

    @State private var temporaryText: String
    @FocusState private var isFocused: Bool

    init(text: Binding<String>) {
        self._text = text
        self.temporaryText = text.wrappedValue
    }

    var body: some View {
        TextField("", text: $temporaryText, onCommit: { text = temporaryText })
            .focused($isFocused, equals: true)
            .onTapGesture { isFocused = true }
            .onExitCommand { temporaryText = text; isFocused = false }
            .contextMenu {
                Button(action: { isFocused = true }, label: { Text("Rename") })
            }
    }
}
```

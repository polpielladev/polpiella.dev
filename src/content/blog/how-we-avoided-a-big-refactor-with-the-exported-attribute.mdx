---
title: 'How to avoid a big refactor with the @_exported attribute'
excerpt: 'A practical use case of the @_exported underscore attribute to avoid a big refactor.'
pubDate: 2023-05-17
---

I have recently used Swift's `@_exported` underscored attribute in a real-world project to minimise the impact of the changes I was introducing and keep the risk of introducing bugs to a minimum.

If you are not familiar with underscored attributes, they are part of the language but only intended to be used within the Swift monorepo as the documentation clearly states.

Despite this, I am going to show an example of a use case where I deemed it appropriate to use the attribute and how it helped me reduce the number of files impacted by a refactor.

## The use case

Let's say you are working on a modular application that is using a custom font and you have a Swift Package containing a `Font` enum which lazily loads the custom font resources and vends them to the rest of your app:

```swift:Font.swift
import UIKit

public enum Font {
    public static let regular: FontProvider = FontProvider(baseFont: FontFamily.MyAwesomeFont.regular)
    public static let medium: FontProvider = FontProvider(baseFont: FontFamily.MyAwesomeFont.medium)
    public static let bold: FontProvider = FontProvider(baseFont: FontFamily.MyAwesomeFont.bold)
}

public struct FontProvider {
    let baseFont: UIFont

    public func font(size: CGFloat, relativeToStyle style: UIFont.TextStyle) -> UIFont {
        let font = baseFont.font(size: size)
        return UIFontMetrics(forTextStyle: style).scaledFont(for: font)
    }

    // Text styles...
    var largeTitle: UIFont { font(size: 32, relativeToStyle: .largeTitle) }
    var title: UIFont { font(size: 28, relativeToStyle: .title1) }
}
```

The different font sizes are accessed by the rest of your app through a series of text styles defined in the `FontProvider` struct.

The views in your app then import the `Fonts` Swift Package and use the `Font` enum directly:

```swift:HomeViewController.swift
import Fonts
import UIKit

class HomeViewController: UIViewController {
    let label = UILabel()

    override func viewDidLoad() {
        super.viewDidLoad()

        label.text = "Hello World"
        label.font = Font.regular.largeTitle
        // ...
    }
}
```

## Reusing font loading code

This code works well but let's now say you or another team in your company are working on a separate app that uses the same custom font but requires different text styles.

You can reuse the font-loading code by removing the text styles from the `FontProvider` struct, moving the `Fonts` Swift Package into its repository, renaming the target and package name (to something like `SharedFonts`) and importing it into both apps:

```swift:Font.swift
import UIKit

public enum Font {
    public static let regular: FontProvider = FontProvider(baseFont: FontFamily.MyAwesomeFont.regular)
    public static let medium: FontProvider = FontProvider(baseFont: FontFamily.MyAwesomeFont.medium)
    public static let bold: FontProvider = FontProvider(baseFont: FontFamily.MyAwesomeFont.bold)
}

public struct FontProvider {
    let baseFont: UIFont

    public func font(size: CGFloat, relativeToStyle style: UIFont.TextStyle) -> UIFont {
        let font = baseFont.font(size: size)
        return UIFontMetrics(forTextStyle: style).scaledFont(for: font)
    }
}
```

The only responsibility that the `SharedFonts` package now has is to load and vend the custom fonts and the responsibility of defining the text styles is now on each of the clients consuming the library.

## Using the new Swift Package without refactoring

In the previous section, we made the conscious decision of renaming the `Fonts` Swift Package to `SharedFonts`. This now allows us to keep our in-source module with the same name to avoid having to make changes to the existing imports across the app.

However, if you now build your application, you will get a compiler error because the `Font` and `FontProvider` symbols are now part of the `SharedFonts` module and there are no text styles defined in the `FontProvider` struct.

To address this, you can replace all files in `Fonts` with a single file that re-exports `SharedFonts` using the `@_exported` attribute and then extends the `FontProvider` struct to define the app-specific text styles:

```swift:FontProvider+TextStyles.swift
import UIKit
// This is the new shared Swift Package
@_exported import SharedFonts

extension FontProvider {
    public var largeTitle: UIFont { font(size: 32, relativeToStyle: .largeTitle) }
    public var title: UIFont { font(size: 28, relativeToStyle: .title1) }
}
```

What doing an `@_exported` import means is that whenever you import the local `Fonts` module, you will also be importing the public interfaces from the `SharedFont` Swift Package, which the views in your app are already using! ðŸŽ‰

The implications of this seemingly small change are great, as you no longer have to make any changes to the views consuming the `Font` enum ðŸŽ‰.

## Proceed with caution

Although this approach works well for this specific use case, it is important to note that the use of the `@_exported` attribute is strongly discouraged outside of the Swift monorepo.

I decided to go with this approach to avoid having to make numerous changes to the existing codebase, which would have made it hard to review, and reduce the risk of introducing bugs across all screens of a big application.

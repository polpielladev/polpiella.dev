---
title: 'Developer guide to Swift AWS Lambdas'
excerpt: "How to write, run locally, and deploy AWS Lambdas."
pubDate: 2024-08-14
tags: ['server-side']
layout: ../../layouts/BlogPostLayout.astro
---

Swift is a mature and powerful language that can be used way beyond development for Apple platforms. Due to its low memory footprint, performance and safety features, it has become a popular choice for server-side development.

## Writing a Lambda function

The first thing we need to do to write a Lambda function in Swift is to create a new executable Swift package:

```bash:Terminal
mkdir my-lambda && cd my-lambda
swift package init --type executable --name MyLambda
```

This will create a new Swift package with the following manifest:

```swift:Package.swift
// swift-tools-version: 6.0

import PackageDescription

let package = Package(
    name: "MyLambda",
    targets: [
        .executableTarget(name: "MyLambda"),
    ]
)
```

### Adding the Swift AWS Lambda Runtime

To be able to write the code for the Lambda function, we need to make use of the [swift-aws-lambda-runtime Swift Package by the Swift Server Work Group](https://github.com/swift-server/swift-aws-lambda-runtime), which provides a Swift implementation of the [AWS Lambda Runtime API](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html) for developers to use:

```swift:Package.swift
// swift-tools-version: 6.0

import PackageDescription

let package = Package(
    name: "MyLambda",
    platforms: [.macOS(.v12)],
    dependencies: [
        .package(
            url: "https://github.com/swift-server/swift-aws-lambda-runtime.git",
            exact: "1.0.0-alpha.2"
        )
    ],
    targets: [
        .executableTarget(
            name: "MyLambda",
            dependencies: [
                .product(name: "AWSLambdaRuntime", package: "swift-aws-lambda-runtime")
            ]
        ),
    ]
)
```

Note that the `swift-aws-lambda-runtime` package has a minimum platform requirement of macOS 12.0, so we need to specify that in the `platforms` section of our package's manifest.

### Writing the Lambda function

Let's now write the code for the Lambda function. The way to do this is to create a struct that is annotated as the entrypoint of the executable using `@main` and conforms to one of the available protocols provided by the `AWSLambdaRuntime` package:

```swift:MyLambda.swift
import AWSLambdaRuntime

struct RequestBody: Decodable {
    let name: String
}

@main
struct MyLambda: SimpleLambdaHandler {
    func handle(_ event: RequestBody, context: AWSLambdaRuntimeCore.LambdaContext) async throws -> String {
        return "You sent: \(event.name)"
    }
}
```

The `SimpleLambdaHandler` protocol is the simplest and most common way to define a Lambda function. It takes a single `event` parameter that must be of `Codable` type and it returns a value of `Codable` type too.

If your use case requires more flexibility, you can conform to one of the other protocols provided by the `AWSLambdaRuntime` package:

1. [EventLoopLambdaHandler](https://github.com/swift-server/swift-aws-lambda-runtime/blob/main/Sources/AWSLambdaRuntimeCore/LambdaHandler.swift#L286): An [EventLoopFuture](https://apple.github.io/swift-nio/docs/current/NIOCore/Classes/EventLoopFuture.html) based implementation of the lambda handlers, which is designed for performance sensitive operations. Contrary to the way in which other implementations work, [EventLoopLambdaHandler](https://github.com/swift-server/swift-aws-lambda-runtime/blob/main/Sources/AWSLambdaRuntimeCore/LambdaHandler.swift#L286) conformant types [execute all code on the same EventLoop as the runtime engine](https://github.com/swift-server/swift-aws-lambda-runtime/blob/main/Sources/AWSLambdaRuntimeCore/LambdaHandler.swift#L282). This allows for a faster execution but requires paying a lot more attention to the implementation so that the EventLoop is never blocked.
2. [ByteBufferLambdaHandler](https://github.com/swift-server/swift-aws-lambda-runtime/blob/main/Sources/AWSLambdaRuntimeCore/LambdaHandler.swift#L401): A lower-level implementation of the [EventLoopLambdaHandler](https://github.com/swift-server/swift-aws-lambda-runtime/blob/main/Sources/AWSLambdaRuntimeCore/LambdaHandler.swift#L286) protocol. It is used by the higher-level [EventLoopLambdaHandler](https://github.com/swift-server/swift-aws-lambda-runtime/blob/main/Sources/AWSLambdaRuntimeCore/LambdaHandler.swift#L286) and, [as the source code states, EventLoopLambdaHandler should be chosen over ByteBufferLambdaHandler by the majority of users](https://github.com/swift-server/swift-aws-lambda-runtime/blob/main/Sources/AWSLambdaRuntimeCore/LambdaHandler.swift#L139).

## Listening to different events

While the code above works and is simple, it is not very a realistic example of a Lambda function. In practice, most Lambda functions are triggered by events sent by and from AWS services. 

For example, a lambda function could be invoked by an S3 bucket event whenever a new file is uploaded to the bucket or by an API Gateway event whenever an HTTP request is made to an endpoint.

[The Swift Server Work Group has created a separate Swift Package with a collection of types that represent the different AWS events that can trigger a Lambda function and the corresponding response types: swift-aws-lambda-events](https://github.com/swift-server/swift-aws-lambda-events):

```swift:Package.swift
// swift-tools-version: 6.0

import PackageDescription

let package = Package(
    name: "MyLambda",
    platforms: [.macOS(.v12)],
    dependencies: [
        .package(
            url: "https://github.com/swift-server/swift-aws-lambda-runtime.git",
            exact: "1.0.0-alpha.2"
        ),
        .package(
            url: "https://github.com/swift-server/swift-aws-lambda-events.git",
            exact: "0.4.0"
        )
    ],
    targets: [
        .executableTarget(
            name: "MyLambda",
            dependencies: [
                .product(name: "AWSLambdaRuntime", package: "swift-aws-lambda-runtime"),
                .product(name: "AWSLambdaEvents", package: "swift-aws-lambda-events")
            ]
        ),
    ]
)

```

These types can be used as the input and return types of the Lambda function we defined earlier in the article. For example, if we wanted to create a Lambda function that is triggered by an APIGateway event, we would write the following code:

```swift:MyLambda.swift 
import Foundation
import AWSLambdaRuntime
import AWSLambdaEvents

struct RequestBody: Decodable {
    let name: String
}

@main
struct MyLambda: SimpleLambdaHandler {
    func handle(
        _ event: APIGatewayV2Request,
        context: AWSLambdaRuntimeCore.LambdaContext
    ) async throws -> APIGatewayV2Response {
        guard let data = event.body?.data(using: .utf8),
              let body = try? JSONDecoder().decode(RequestBody.self, from: data) else {
            return .init(statusCode: .badRequest)
        }
        
        return .init(statusCode: .ok, body: "Your name is: \(body.name)")
    }
}
```

As you can see in the code snippet above, the input type is no longer our `Codable` struct, but an `APIGatewayV2Request` type. This type is defined in the `AWSLambdaEvents` package and represents the event that is sent by the API Gateway service to the Lambda function.

Similarly, the return type is no longer a `String`, but an `APIGatewayV2Response` type. This type is also defined in the `AWSLambdaEvents` package and represents the response that the Lambda function sends back to the API Gateway service. Among other things, using this type we can provide the status code and body of the response, which we set to `200 OK` and `Your name is: <name>` respectively.

## Running the lambda locally

Running the lambda function locally is a great way to test your changes before deploying them to AWS. The `swift-aws-lambda-runtime` allows you to run the executable where your Lambda function is defined as a local server by passing the `LOCAL_LAMBDA_SERVER_ENABLED=true` argument.

You can do this from the command line:

```bash:Terminal
LOCAL_LAMBDA_SERVER_ENABLED=true swift run
```

Or by modifying the scheme in Xcode to add the `LOCAL_LAMBDA_SERVER_ENABLED=true` argument in the `Arguments Passed On Launch` section and then running it:

<Video name="" />

Running the executable will spin up a server that listens for `POST`s requests on `http://127.0.0.1:7000/invoke`. You can then use a tool like `curl` or a client like [HTTPie]() to send requests to the new local server. The body of the request will need to match the structure and data that the Lambda function expects. 

For our example, we must send a JSON object in the shape of an `APIGatewayV2Request` event, where we can specify the method and body of the request:

```json 
{
    "routeKey": "POST /hello",
    "version": "2.0",
    "rawPath": "/hello",
    "stageVariables": {},
    "requestContext": {
        "timeEpoch": 1723647331,
        "domainPrefix": "name",
        "accountId": "0123456789",
        "stage": "$default",
        "domainName": "pol.com",
        "apiId": "abcdefg",
        "requestId": "abcdefg",
        "http": {
            "path": "/name",
            "userAgent": "Mozilla/5.0 (platform; rv:geckoversion) Gecko/geckotrail Firefox/firefoxversion",
            "method": "POST",
            "protocol": "HTTP/1.1",
            "sourceIp": "93.212.3.65"
        },
        "time": "14/Aug/2024:16:55:00 +0000"
    },
    "body": "{\"name\":\"Pol\"}",
    "isBase64Encoded": false,
    "rawQueryString": "",
    "headers":{
        "host": "pol.com",
        "user-agent": "Mozilla/5.0 (platform; rv:geckoversion) Gecko/geckotrail Firefox/firefoxversion",
        "content-length": "0"
    }
}
```

## Logging and debugging

Aside from the input parameter, the `handle` function also receives a `context` parameter of type `LambdaContext`. This parameter provides information about the execution environment of the Lambda function, such as the AWS request ID or the cognito identity ID of the caller.

Aside from plenty of useful information, the `LambdaContext` also provides a `logger` property that can be used to add messages to the AWS CloudWatch logs with different levels of importance. Such logs can be useful for debugging issues in production where you can't use a debugger. 

Let's add some logs to our Lambda function: 

```swift:MyLambda.swift
import Foundation
import AWSLambdaRuntime
import AWSLambdaEvents

@main
struct MyLambda: SimpleLambdaHandler {
    func handle(
        _ event: APIGatewayV2Request,
        context: AWSLambdaRuntimeCore.LambdaContext
    ) async throws -> APIGatewayV2Response {
        guard let data = event.body?.data(using: .utf8),
              let body = try? JSONDecoder().decode(RequestBody.self, from: data) else {
            context.logger.error("Could not decode data for: \(event.body)")
            return .init(statusCode: .badRequest)
        }
        
        context.logger.info("Received request for name: \(body.name)")
        return .init(statusCode: .ok, body: "Your name is: \(body.name)")
    }
}
```

## Using frameworks in Swift Lambdas

## Building and deploying

Once you have the Lambda function building and running locally, you need to compile it into a suitable format and deploy it to AWS. The [swift-aws-lambda-runtime Swift Package]() vends a command plugin that uses Docker under the hood to compile the Swift code for the `amazonlinux2` platform and package it into a zip file that can be uploaded to AWS:

```bash:Terminal
swift package --disable-sandbox archive
```

This command will create a zip file at `.build/plugins/AWSLambdaPackager/outputs/AWSLambdaPackager/MyLambda/MyLambda.zip` that can be uploaded to AWS.

While you can set up the whole AWS infrastructure for your serverless application manually, I would highly recommend using the [SAM CLI](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html), which allows you to describe your serverless infrastructure using code in a `template.yml` file and package and deploy it to AWS using the `sam deploy` command.

To deploy a single lambda function with an associated API Gateway endpoint, you can use the following `template.yml` file:

```yaml:template.yml
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31

Resources:
  PostNameFunction:
    Type: AWS::Serverless::Function
    Properties:
      PackageType: Zip
      CodeUri: .build/plugins/AWSLambdaPackager/outputs/AWSLambdaPackager/MyLambda/MyLambda.zip
      Handler: bootstrap
      Runtime: provided.al2
      MemorySize: 128
      Timeout: 30
      Architectures:
        - arm64
      Events:
        # handles the GET /items method of the REST API
        Api:
          Type: HttpApi
          Properties:
            Method: post
            Path: /name

Outputs:
  SwiftAPIEndpoint:
    Description: "API Gateway endpoint URL for your application"
    Value: !Sub "https://${ServerlessHttpApi}.execute-api.${AWS::Region}.amazonaws.com"
```

You can then deploy the Lambda function and the API Gateway endpoint using the following command:

```bash:Terminal
sam build
sam deploy --guided
```

Alternatively, you can use a CI/CD service like GitHub Actions to automate the deployment process:

```yaml:.github/workflows/deploy.yml
on:
  push:
    branches:
      - main
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: aws-actions/setup-sam@v2
      - uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-2
      - name: Build executable
        run: swift package --disable-sandbox archive
      - run: sam build --use-container
      - run: sam deploy --no-confirm-changeset --no-fail-on-empty-changeset
```
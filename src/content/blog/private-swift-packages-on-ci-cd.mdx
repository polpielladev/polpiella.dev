---
title: 'Private Swift packages on CI/CD'
excerpt: 'How to build an app that depends on private Swift packages on CI/CD.'
pubDate: 2023-05-24
---

At work we have recently started to use Swift packages to share code between our iOS apps across different products and teams.
Due to the nature of the code we are sharing, we needed the host the packages on internal GitHub repositories accessible only to our organisation.

This caused a myriad of issues when trying to build our app on CI/CD using these new packages as we had previously only dependend on public packages in the past.

In this article I will go through the solution we came up with and how we leveraged the use of GitHub personal access tokens to make it work on CI/CD.

## The requirements

We use GitHub actions as our CI/CD tool of choice and, by default, it clones the current repository using a short-lived token with a very narrow scope through the `@actions/checkout` action.

For this reason, our runners are not set up to use SSH keys and by default only have access to the repository that triggered the workflow. Access to any other repositories must be granted explicitly through the use of an elevated access token.

We wanted to preserve this behaviour only grant access during the execution of a workflow, so we decided to use a personal access token with access to clone all repositories in our organisation.

## Building the app locally

All developers in our team use SSH keys to authenticate with GitHub and have access to all repositories in our organisation.

For this reason, we decided to define our private Swift package dependencies using SSH URLs in the `Package.swift` manifest:

```swift:Package.swift
// swift-tools-version:5.7

import PackageDescription

let package = Package(
    name: "YourAwesomePackage",
    products: [
        .library(
            name: "YourAwesomePackage",
            targets: ["YourAwesomePackage"]
        )
    ],
    dependencies: [
        .package(url: "git@github.com:your-org/your-dependency.git", exact: "1.0.0")
    ],
    targets: [
        .target(
            name: "YourAwesomePackage",
            dependencies: [.product(name: "YourDependency", package: "your-dependency")]
        )
    ]
)
```

## Building the app on CI/CD

Now that the app was building locally, we needed to make it work on CI/CD.

### Modifying the global git config

By now you might be thinking that I have contradicted myself. I started the article by saying that we wanted to use personal access tokens to build our app on CI/CD, but then I went ahead and defined our dependencies using SSH URLs.

The cool thing about git is that you can provide overrides for the way it clones repositories through the git config file. This way, we can tell git to use HTTPS URLs instead of SSH URLs when cloning repositories on CI/CD while keeping SSH keys locally:

```yml:override-git-config
[url "https://github.com/"]
	insteadOf = git@github.com:
```

This `override-git-config` file can be commited to the repository and then used to override the global git config on CI/CD for the current session only through environment variables:

> Note that I am using a fastlane lane in this example, but you can use any other tool to achieve the same result.

```ruby
desc "Set up git credentials"
private_lane :cache_git_crendetials do
  ENV["GIT_CONFIG_GLOBAL"] = "#{ENV['PWD']}/override-git-config"
end
```

### Storing the access token in the cache

By default, macOS runners have a system git config file which defaults to using the `keychain` as the git credential helper. This causes any access token used for authentication to be stored in the system forever, causing the runner to have access to clone repositories even after the workflow has finished.

To override this behaviour, we had to override the system git config file we created earlier to use `cache` as the git credential helper instead:

```yml:override-git-config
[credential]
	helper = cache --timeout 900
[url "https://github.com/"]
	insteadOf = git@github.com:
```

The beauty of this approach is that, due to the way the cache credential helper works, the credentials will always be stored in an in-memory cache and never to a file. Furthermore, as we are setting a timeout of 900 seconds, the credentials will be removed from the cache 15 minutes after they are used (e.g. after cloning a repository).

In macOS runners, we had to tell git to ignore the system git config file through an environment variable to stop using the keychain as the credential helper during the current session:

```ruby
desc "Set up git credentials"
private_lane :cache_git_crendetials do
  ENV["GIT_CONFIG_GLOBAL"] = "#{ENV['PWD']}/override-git-config"
  ENV["GIT_CONFIG_NOSYSTEM"] = "true"
end
```

### Removing the access token from the cache

```

```

---
title: 'GitHub web hooks ðŸ¤ Xcode Cloud'
excerpt: 'How to use GitHub web hooks to trigger Xcode Cloud builds by writing a comment on a pull request.'
pubDate: 2023-03-15
---

Websites like GitHub provide ways of expanding their default behaviour through a set of automated messages which get sent when specific events happen called web hooks.

When you set up a webhook, you provide a URL to which GitHub sends a `POST` request with information on the subscribed to event as the body of the request.

GitHub has a set of web hooks you can subscribe to, such as the [issue_comment]() event, which gets called when a user adds a comment to a pull request or an issue on a repository.

In this article, you will learn how to write a serverless Swift function to listen to the [issue_comment]() web hook events and, if a pull request's comment's body matches the 'Upload to TestFlight' string, trigger an Xcode Cloud build which uploads the app for internal testing on TestFlight.

## The Xcode Cloud workflow

Before starting the automation process, you first need to set up an Xcode Cloud workflow which uploads the app to TestFlight from any branch.

To create a new workflow, go to the `Report Navigator` menu, select the `Cloud` menu, right click on the target you want to create the new wokflow for and select `Manage Workflows...`.

![](https://res.cloudinary.com/dflewmkx4/image/upload/ac_none,f_auto,q_auto:eco/v1678797532/blog/posts/github-webhooks-and-xcode-cloud/manage-workflows.png)

In the workflow list screen, click on the `+` button to create a new workflow.

![](https://res.cloudinary.com/dflewmkx4/image/upload/ac_none,f_auto,q_auto:eco/v1678797532/blog/posts/github-webhooks-and-xcode-cloud/create.png)

Change the name of the workflow to 'Testflight' and disable the workflow so that the workflow only runs manually.

![](https://res.cloudinary.com/dflewmkx4/image/upload/ac_none,f_auto,q_auto:eco/v1678797531/blog/posts/github-webhooks-and-xcode-cloud/manual-workflow.png)

Add a start condition to start the workflow on any branch change.

![](https://res.cloudinary.com/dflewmkx4/image/upload/ac_none,f_auto,q_auto:eco/v1678797532/blog/posts/github-webhooks-and-xcode-cloud/archive-any-branch.png)

Add an archive action and select the `TestFlight (Internal Testing Only)` option.

![](https://res.cloudinary.com/dflewmkx4/image/upload/ac_none,f_auto,q_auto:eco/v1678798727/blog/posts/github-webhooks-and-xcode-cloud/archive-internal-testing.png)

Add a post action step to deliver the app to TestFlight for internal testing. You need to add a test group for this step to work.

![](https://res.cloudinary.com/dflewmkx4/image/upload/ac_none,f_auto,q_auto:eco/v1678797531/blog/posts/github-webhooks-and-xcode-cloud/internal-testing.png)

The Testflight workflow is now able to upload the app to TestFlight and distribute it to an internal test group. The workflow is also disabled so that it just runs when you manually trigger it rather than on any branch change.

## Setting up the Amazon Web Services lambda

### Creating a Swift package

To create an Amazon Web Services lambda, you first need to create an executable Swift package:

```bash:Terminal
# Create an empty directory
mkdir upload-to-testflight-webhook
# Move into the new directory
cd upload-to-testflight-webhook
# Create a new executable Swift package
swift package init --type executable --name UploadToTestFlightWebhook
```

The preceding command generates an executable Swift package with the following structure:

```bash:ðŸ“¦
.
â”œâ”€â”€ Package.swift
â”œâ”€â”€ README.md
â”œâ”€â”€ Sources
â”‚   â””â”€â”€ UploadToTestFlightWebhook
â”‚       â””â”€â”€ UploadToTestFlightWebhook.swift
â””â”€â”€ Tests
    â””â”€â”€ UploadToTestFlightWebhookTests
        â””â”€â”€ UploadToTestFlightWebhookTests.swift
```

### Adding the dependencies

The [swift-server group]() provides a Swift package called [swift-aws-lambda-runtime]() to create Amazon Web Services lambdas using Swift.

The lambda needs to listen to `POST` requests sent by GitHub and, for this reason, needs to have an Amazon API Gateway as its trigger. To read data from the gateway's body, you need to add the [swift-aws-lambda-events]() package as a dependency.

```swift:Package.swift
// swift-tools-version: 5.7

import PackageDescription

let package = Package(
    name: "UploadToTestFlightWebhook",
    platforms: [.macOS(.v12)],
    dependencies: [
        .package(url: "https://github.com/swift-server/swift-aws-lambda-runtime.git", exact: "1.0.0-alpha.1"),
        .package(url: "https://github.com/swift-server/swift-aws-lambda-events.git", exact: "0.1.0")
    ],
    targets: [
        .executableTarget(
            name: "UploadToTestFlightWebhook",
            dependencies: [
                .product(name: "AWSLambdaRuntime", package: "swift-aws-lambda-runtime"),
                .product(name: "AWSLambdaEvents", package: "swift-aws-lambda-events")
            ]
        )
    ]
)
```

### Creating an empty lambda

To create an Amazon Web Services lambda which handles API Gateway events, you need to import both the `AWSLambdaRuntime` and `AWSLambdaEvents` packages and create a `@main` decorated `struct` which conforms to the `LambdaHandler` protocol.

```swift:Sources/UploadToTestFlightWebhook/UploadToTestFlightWebhook.swift
import AWSLambdaRuntime
import AWSLambdaEvents

@main
struct UploadToTestFlightWebhook: SimpleLambdaHandler {
    func handle(_ request: APIGatewayV2Request, context: LambdaContext) async throws -> APIGatewayV2Response {
        return .init(
            statusCode: .ok,
            body: "Hello World ðŸ‘‹"
        )
    }
}
```

## Parsing the web hook's payload

The GitHub [issue_comment]() webhook sends a payload with the relevant information for a pull request comment.

From all the information in the payload, the web hook just needs the following information:

```json:payload.json
{
  "action": "created",
  "issue": {
    "pull_request": {
      "url": "https://api.github.com/repos/polpielladev/QRBuddy/pulls/1"
    }
  },
  "repository": {
    "name": "QRBuddy"
  },
  "comment": {
    "body": "Upload to testflight"
  }
}
```

> The preceding payload represents a simplified version of the actual payload sent by GitHub.

To parse the payload, the lambda needs to decode the `APIGatewayV2Request`'s `body` property into a `GithubWebhookData` struct.

```swift:Sources/UploadToTestFlightWebhook/UploadToTestFlightWebhook.swift
struct GithubWebhookData: Decodable {
    let action: String
    let issue: Issue
    let repository: Repository
    let comment: Comment

    struct Issue: Decodable {
        let pullRequest: PullRequest

        struct PullRequest: Decodable {
            let url: URL
        }
    }

    struct Repository: Decodable {
        let name: String
    }

    struct Comment: Decodable {
        let body: String
    }
}

@main
struct UploadToTestFlightWebhook: SimpleLambdaHandler {
    let snakeCaseDecoder: JSONDecoder

    init() {
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        snakeCaseDecoder = decoder
    }

    func handle(_ request: APIGatewayV2Request, context: LambdaContext) async throws -> APIGatewayV2Response {
        guard let body = request.body,
              let bodyData = body.data(using: .utf8),
              let request = try? snakeCaseDecoder.decode(GithubWebhookData.self, from: bodyData) else {
            return .init(statusCode: .badRequest, body: "Could not parse the request content...")
        }

        guard request.action == "created",
              request.comment.body.lowercased() == "upload to testflight" else {
            return .init(statusCode: .ok, body: "Not handling the event...")
        }

        // â¬‡ï¸
    }
}
```

The lambda needs to handle just the `created` action to ensure it triggers builds for new comments and not for comment edits or deletions.

As stated in the introduction, the lambda should just trigger builds when the comment matches 'Upload to TestFlight'.

## Retrieving the pull request's information

While the GitHub [issue_comment]() webhook sends some pull request's information, it doesn't send enough to determine the pull request's head branch.

To find the pull request's head branch's name, the lambda needs to make a `GET` request to the `pullRequest`'s `url` property from the webhook's event payload.

This property is a URL pointing to the [pulls]() GitHub endpoint, which requires authentication for private repositories. The lambda can the access the `head.ref` property from GitHub's response to get the pull request's head's branch name.

```swift:Sources/UploadToTestFlightWebhook/UploadToTestFlightWebhook.swift
struct GithubPullRequest: Decodable {
    let head: Head

    struct Head: Decodable {
        let ref: String
    }
}

@main
struct UploadToTestFlightWebhook: SimpleLambdaHandler {
    func handle(_ request: APIGatewayV2Request, context: LambdaContext) async throws -> APIGatewayV2Response {
        // ...

        var urlRequest = URLRequest(url: request.issue.pullRequest.url)
        urlRequest.setValue("Bearer ðŸ™ˆ", forHTTPHeaderField: "Authorization")
        // Small helper class to make async requests
        let urlSession = URLSessionWrapper()
        let data = try await urlSession.data(for: urlRequest)

        let headBranchName = try snakeCaseDecoder.decode(GithubPullRequest.self, from: data)
            .head
            .ref

        // ...
    }
}
```

## Importing appstoreconnect-swift-sdk

To make it easier to interact with App Store Connect, the lambda uses [Antoine van der Lee's appstoreconnect-swift-sdk Swift package]():

```swift:Package.swift
// swift-tools-version: 5.7

import PackageDescription

let package = Package(
    name: "UploadToTestFlightWebhook",
    platforms: [.macOS(.v12)],
    dependencies: [
        // Use the master revision as it implements Linux compatibility
        .package(url: "https://github.com/AvdLee/appstoreconnect-swift-sdk.git", revision: "master"),
        .package(url: "https://github.com/swift-server/swift-aws-lambda-runtime.git", exact: "1.0.0-alpha.1"),
        .package(url: "https://github.com/swift-server/swift-aws-lambda-events.git", exact: "0.1.0")
    ],
    targets: [
        .executableTarget(
            name: "UploadToTestFlightWebhook",
            dependencies: [
                .product(name: "AWSLambdaRuntime", package: "swift-aws-lambda-runtime"),
                .product(name: "AWSLambdaEvents", package: "swift-aws-lambda-events")
            ]
        )
    ]
)
```

### Setting up the `APIProvider`

The `APIProvider` provides a way to interact with App Store Connect's API. It requires an `APIConfiguration` with App Store Connect's credentials to make authenticated requests.

```swift:Sources/UploadToTestFlightWebhook/UploadToTestFlightWebhook.swift
// ...
import AppStoreConnect_Swift_SDK

@main
struct UploadToTestFlightWebhook: SimpleLambdaHandler {
    func handle(_ request: APIGatewayV2Request, context: LambdaContext) async throws -> APIGatewayV2Response {
        // ...

        let config = try APIConfiguration(
            issuerID: "ðŸ™ˆ",
            privateKeyID: "ðŸ™ˆ",
            privateKey: "ðŸ™ˆ"
        )

        let provider = APIProvider(configuration: config)

        // ...
    }
}
```

> This article doesn't go into detail on how to retrieve the credentials from App Store Connect. For more information, refer to the [ article]().

## Triggering an Xcode Cloud build

The lambda now has all the tools and information it needs to interact with the App Store Connect API and trigger a new build from the `TestFlight` workflow.

### Finding the correct product

The lambda needs to find the product that matches the pull request's repository name by:

1. Making a request to the `ciProducts` endpoint from the App Store Connect API to get all the products of type `app`.
2. Find the product that matches the pull request's repository name by comparing the `repositoryName` property from the `scmRepository` included item with the pull request's repository name and get the repository entity's `id`.
3. Find the product that matches the repository entity's `id` by comparing the `repositoryId` property from the `product`'s `relationships` with the repository entity's `id`. If the repository has no matching product, return a `404` response.

```swift:Sources/UploadToTestFlightWebhook/UploadToTestFlightWebhook.swift
@main
struct UploadToTestFlightWebhook: SimpleLambdaHandler {
    func handle(_ request: APIGatewayV2Request, context: LambdaContext) async throws -> APIGatewayV2Response {
        // ...

        let producstEndpoint = APIEndpoint
                .v1
                .ciProducts
                .get(parameters: .init(filterProductType: [.app], include: [.primaryRepositories, .bundleID]))

        let productResponse = try await provider.request(producstEndpoint)

        guard let repositoryId: String = productResponse
            .included?
            .compactMap({ includedItem in
                switch includedItem {
                case .scmRepository(let scmData) where scmData.attributes?.repositoryName == request.repository.name:
                    return scmData.id
                default: return nil
                }
            })
            .first,

        let productId = productResponse.data.first(where: {
            $0.relationships?.primaryRepositories?.data?.contains { $0.id == repositoryId } == true
        })?.id else {
            return .init(statusCode: .notFound, body: "Could not find a product for this repository")
        }

        // ...
    }
}
```

### Getting the TestFlight workflow id

The lambda can now try to find the id for the `TestFlight` workflow from the product id retrieved in the previous section by:

1. Making a request to the `ciProducts/{productId}/workflows` endpoint from the App Store Connect API to get all the workflows for the product.
2. Finding the `TestFlight` workflow by getting the first item in the workflows' array whose name matches `TestFlight`. If no `TestFlight` workflow exists, return a response with `404` status code.

```swift:Sources/UploadToTestFlightWebhook/UploadToTestFlightWebhook.swift
@main
struct UploadToTestFlightWebhook: SimpleLambdaHandler {
    func handle(_ request: APIGatewayV2Request, context: LambdaContext) async throws -> APIGatewayV2Response {
        // ...

        let allWorkflowsEndpoint = APIEndpoint
            .v1
            .ciProducts
            .id(productId)
            .workflows

        let workflows = try await provider
            .request(
                Request<WorkflowsResponse>(
                    method: "GET",
                    path: allWorkflowsEndpoint.path,
                    query: [("fields[ciWorkflows]", "name")]
                )
            )

        guard let workflowId = workflows.data.first(where: { $0.attributes.name == "Testflight" })?.id else {
            return .init(statusCode: .notFound, body: "Could not find a `TestFlight` workflow in product")
        }

        // ...
    }
}
```

### Finding the correct git reference id

To start a new workflow run from a specific branch, the App Store Connect API requires the id of the git reference for that branch.

Contrary to what you might think, this id is Xcode Cloud specific and not the same as the ref from the GitHub branch.

To get the correct id, the lambda now needs to:

1. Retrieve the `TestFlight` workflow information from the App Store Connect API and specify that the response must include the `repository` information.
2. Retrieve the git references for the repository from the `scmRepositories/gitReferences` endpoint.
3. Filter the git references array to find the object whose name matches the pull request's head branch's name. If no matching git reference exists, return a response with `404` status code.

```swift:Sources/UploadToTestFlightWebhook/UploadToTestFlightWebhook.swift
@main
struct UploadToTestFlightWebhook: SimpleLambdaHandler {
    func handle(_ request: APIGatewayV2Request, context: LambdaContext) async throws -> APIGatewayV2Response {
        // ...

        let workflowEndpoint = APIEndpoint
            .v1
            .ciWorkflows
            .id(workflowId)
            .get(parameters: .init(include: [.repository]))

        let workflow = try await provider.request(workflowEndpoint).data

        let gitRefsEndpoint = APIEndpoint
            .v1
            .scmRepositories
            .id(repositoryId)
            .gitReferences
            .get()

        let gitRefs = try await provider.request(gitRefsEndpoint)

        guard let ref = gitRefs.data.first(where: { $0.attributes?.name == headBranchName }) else {
            return .init(statusCode: .notFound, body: "There is no branch named \(headBranchName) in the repository")
        }

        // ...
    }
}
```

### Starting a new build

With all information available now, the lambda can start a new build by:

1. Creating a new `CiBuildRunCreateRequest` object with the workflow and the source branch as relationships for the request.
2. Making a request to the `ciBuildRuns` endpoint from the App Store Connect API to start a new build run.
3. Return a response with `200` status code.

```swift:Sources/UploadToTestFlightWebhook/UploadToTestFlightWebhook.swift
@main
struct UploadToTestFlightWebhook: SimpleLambdaHandler {
    func handle(_ request: APIGatewayV2Request, context: LambdaContext) async throws -> APIGatewayV2Response {
        // ...

        let requestRelationships = CiBuildRunCreateRequest
            .Data
            .Relationships(
                workflow: .init(data: .init(type: .ciWorkflows, id: workflow.id)),
                sourceBranchOrTag: .init(data: .init(type: .scmGitReferences, id: ref.id))
            )
            let requestData = CiBuildRunCreateRequest.Data(
                type: .ciBuildRuns,
                relationships: requestRelationships
            )

        let buildRunCreateRequest = CiBuildRunCreateRequest(data: requestData)

        let workflowRun = APIEndpoint
            .v1
            .ciBuildRuns
            .post(buildRunCreateRequest)

        _ = try await provider.request(workflowRun)

        return .init(
            statusCode: .ok,
            body: "Job \(workflow.attributes?.name ?? "") triggered."
        )
    }
}
```

---
title: 'GitHub web hooks 🤝 Xcode Cloud'
excerpt: 'How to use GitHub web hooks to trigger Xcode Cloud builds by writing a comment on a pull request.'
pubDate: 2023-03-15
---

Websites like GitHub provide ways of expanding their default behaviour through a set of automated messages which get sent when specific events happen called web hooks.

When you set up a webhook, you provide a URL to which GitHub sends a `POST` request with information on the subscribed to event as the body of the request.

GitHub has a set of web hooks you can subscribe to, such as the [issue_comment]() event, which gets called when a user adds a comment to a pull request or an issue on a repository.

In this article, you will learn how to write a serverless Swift function to listen to the [issue_comment]() web hook events and, if a pull request's comment's body matches the 'Upload to TestFlight' string, trigger an Xcode Cloud build which uploads the app for internal testing on TestFlight.

## Setting up the Amazon Web Services lambda

### Creating a Swift package

To create an Amazon Web Services lambda, you first need to create an executable Swift package:

```bash
# Create an empty directory
mkdir upload-to-testflight-webhook
# Move into the new directory
cd upload-to-testflight-webhook
# Create a new executable Swift package
swift package init --type executable --name UploadToTestFlightWebhook
```

The preceding command generates an executable Swift package with the following structure:

```bash
.
├── Package.swift
├── README.md
├── Sources
│   └── UploadToTestFlightWebhook
│       └── UploadToTestFlightWebhook.swift
└── Tests
    └── UploadToTestFlightWebhookTests
        └── UploadToTestFlightWebhookTests.swift
```

### Adding the dependencies

The [swift-server group]() provides a Swift package called [swift-aws-lambda-runtime]() to create Amazon Web Services lambdas using Swift.

The lambda needs to listen to `POST` requests sent by GitHub and, for this reason, needs to have an Amazon API Gateway as its trigger. To read data from the gateway's body, you need to add the [swift-aws-lambda-events]() package as a dependency.

```swift:Package.swift
// swift-tools-version: 5.7

import PackageDescription

let package = Package(
    name: "UploadToTestFlightWebhook",
    platforms: [.macOS(.v12)],
    dependencies: [
        .package(url: "https://github.com/swift-server/swift-aws-lambda-runtime.git", exact: "1.0.0-alpha.1"),
        .package(url: "https://github.com/swift-server/swift-aws-lambda-events.git", exact: "0.1.0")
    ],
    targets: [
        .executableTarget(
            name: "UploadToTestFlightWebhook",
            dependencies: [
                .product(name: "AWSLambdaRuntime", package: "swift-aws-lambda-runtime"),
                .product(name: "AWSLambdaEvents", package: "swift-aws-lambda-events")
            ]
        )
    ]
)
```

### Creating an empty lambda

To create an Amazon Web Services lambda which handles API Gateway events, you need to import both the `AWSLambdaRuntime` and `AWSLambdaEvents` packages and create a `@main` decorated `struct` which conforms to the `LambdaHandler` protocol.

```swift:Sources/UploadToTestFlightWebhook/UploadToTestFlightWebhook.swift
import AWSLambdaRuntime
import AWSLambdaEvents

@main
struct UploadToTestFlightWebhook: SimpleLambdaHandler {
    func handle(_ request: APIGatewayV2Request, context: LambdaContext) async throws -> APIGatewayV2Response {
        return .init(
            statusCode: .ok,
            body: "Hello World 👋"
        )
    }
}
```

## Parsing the web hook's payload

The GitHub [issue_comment]() webhook sends a payload with the relevant information for a pull request comment.

From all the information in the payload, the web hook just needs the following information:

```json:payload.json
{
  "action": "created",
  "issue": {
    "pull_request": {
      "url": "https://api.github.com/repos/polpielladev/QRBuddy/pulls/1"
    }
  },
  "repository": {
    "name": "QRBuddy"
  },
  "comment": {
    "body": "Upload to testflight"
  }
}
```

> The preceding payload represents a simplified version of the actual payload sent by GitHub.

To parse the payload, the lambda needs to decode the `APIGatewayV2Request`'s `body` property into a `GithubWebhookData` struct.

```swift:Sources/UploadToTestFlightWebhook/UploadToTestFlightWebhook.swift
struct GithubWebhookData: Decodable {
    let action: String
    let issue: Issue
    let repository: Repository
    let comment: Comment

    struct Issue: Decodable {
        let pullRequest: PullRequest

        struct PullRequest: Decodable {
            let url: URL
        }
    }

    struct Repository: Decodable {
        let name: String
    }

    struct Comment: Decodable {
        let body: String
    }
}

@main
struct UploadToTestFlightWebhook: SimpleLambdaHandler {
    let snakeCaseDecoder: JSONDecoder

    init() {
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        snakeCaseDecoder = decoder
    }

    func handle(_ request: APIGatewayV2Request, context: LambdaContext) async throws -> APIGatewayV2Response {
        guard let body = request.body,
              let bodyData = body.data(using: .utf8),
              let request = try? snakeCaseDecoder.decode(GithubWebhookData.self, from: bodyData) else {
            return .init(statusCode: .badRequest, body: "Could not parse the request content...")
        }

        guard request.action == "created",
              request.comment.body.lowercased() == "upload to testflight" else {
            return .init(statusCode: .ok, body: "Not handling the event...")
        }

        // ⬇️
    }
}
```

The lambda needs to handle just the `created` action to ensure it triggers builds for new comments and not for comment edits or deletions.

As stated in the introduction, the lambda should just trigger builds when the comment matches 'Upload to TestFlight'.

## Retrieving the pull request's information

While the GitHub [issue_comment]() webhook sends some pull request's information, it doesn't send enough to determine the pull request's head branch.

To find the pull request's head branch's name, the lambda needs to make a `GET` request to the `pullRequest`'s `url` property from the webhook's event payload.

This property is a URL pointing to the [pulls]() GitHub endpoint, which requires authentication for private repositories. The lambda can the access the `head.ref` property from GitHub's response to get the pull request's head's branch name.

```swift:Sources/UploadToTestFlightWebhook/UploadToTestFlightWebhook.swift
struct GithubPullRequest: Decodable {
    let head: Head

    struct Head: Decodable {
        let ref: String
    }
}

@main
struct UploadToTestFlightWebhook: SimpleLambdaHandler {
    func handle(_ request: APIGatewayV2Request, context: LambdaContext) async throws -> APIGatewayV2Response {
        // ...

        var urlRequest = URLRequest(url: request.issue.pullRequest.url)
        urlRequest.setValue("Bearer 🙈", forHTTPHeaderField: "Authorization")
        // Small helper class to make async requests
        let urlSession = URLSessionWrapper()
        let data = try await urlSession.data(for: urlRequest)

        let headBranchName = try snakeCaseDecoder.decode(GithubPullRequest.self, from: data)
            .head
            .ref

        // ...
    }
}
```

## Importing appstoreconnect-swift-sdk

## Triggering an Xcode Cloud build

### Finding the correct product

### Getting the TestFlight workflow id

### Finding the correct git reference id

### Starting a new build

````

```

```
````

---
import type {
  Indices,
  Tweet,
  HashtagEntity,
  UserMentionEntity,
  UrlEntity,
  MediaEntity,
} from '../types'
import { getHashtagUrl, getUserUrl } from '../utils'
import TweetLink from './TweetLink.astro'

type TextEntity = {
  indices: Indices
  type: 'text'
}

type Entity =
  | TextEntity
  | (HashtagEntity & { type: 'hashtag' })
  | (UserMentionEntity & { type: 'mention' })
  | (UrlEntity & { type: 'url' })
  | (MediaEntity & { type: 'media' })

function addEntities(
  result: Entity[],
  entities: (HashtagEntity | UserMentionEntity | MediaEntity)[],
  type: Entity['type']
) {
  for (const entity of entities) {
    for (const [i, item] of result.entries()) {
      if (
        entity.indices[0] < item.indices[0] ||
        entity.indices[1] > item.indices[1]
      ) {
        continue
      }

      const items = [{ ...entity, type }] as Entity[]

      if (item.indices[0] < entity.indices[0]) {
        items.unshift({
          indices: [item.indices[0], entity.indices[0]],
          type: 'text',
        })
      }
      if (item.indices[1] > entity.indices[1]) {
        items.push({
          indices: [entity.indices[1], item.indices[1]],
          type: 'text',
        })
      }

      result.splice(i, 1, ...items)

      break
    }
  }
}

function getEntities(tweet: Tweet) {
  const result: Entity[] = [{ indices: tweet.display_text_range, type: 'text' }]

  addEntities(result, tweet.entities.hashtags, 'hashtag')
  addEntities(result, tweet.entities.user_mentions, 'mention')
  addEntities(result, tweet.entities.urls, 'url')
  if (tweet.entities.media) {
    addEntities(result, tweet.entities.media, 'media')
  }

  return result
}

export interface Props {
  tweet: Tweet
}

const { tweet } = Astro.props

const entities = getEntities(tweet)
---

<p class="root">{
    entities.map((item, index) => {
      let text: string

      const previousEntity = entities[index - 1]
      if (previousEntity && (previousEntity.type === 'url' || previousEntity.type === 'hashtag')) {
        text = tweet.text.slice(item.indices[0] + 1, item.indices[1])
      } else {
        text = tweet.text.slice(item.indices[0], item.type == 'hashtag' ? item.indices[1] + 1 : item.indices[1])
      }

      const nextEntity = entities[index + 1]
      if (nextEntity && nextEntity.type == 'url') {
        text = text + ' '
      }

      switch (item.type) {
        case 'hashtag':
          return <TweetLink href={getHashtagUrl(item)} displayUrl={text} />
        case 'mention':
          return (
            <TweetLink href={getUserUrl(item.screen_name)} displayUrl={text} />
          )
        case 'url':
          return (
            <TweetLink href={item.expanded_url} displayUrl={item.display_url} />
          )
        case 'media':
          // Media text is currently never displayed, some tweets however might have indices
          // that do match `display_text_range` so for those cases we ignore the content.
          return undefined
        default:
          return <span>{text}</span>
      }
    })
  }</p>

<style>
  .root {
    line-height: 1.5rem;
    font-size: 1.25rem;
    overflow-wrap: break-word;
    white-space: pre-wrap;
  }
</style>
